<?xml version="1.0"?>
<ruleset name="Codecop"
    xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">

   <description>
      Mix of rules for various bugs and conventions. Some of these should really be in the core of PMD.
      Others are likely to be controversial.
   </description>


   <!-- basic.xml --> <!-- by Richard Beitelmair -->
   <rule name="JumbledIterator"
         language="java"
         message="Non matching iterator identifier found in for loop."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#jumblediterator">
      <description>
         The used Iterator for the 'exit expression' in a for loop does not match the 'declaration expression', most likely this is not intended.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
             <value>
<![CDATA[
//ForStatement[
  ( ForInit//ClassOrInterfaceType/@Image='Iterator' or
    ForInit//ClassOrInterfaceType/@Image='Enumeration'
  ) and
  ( ends-with(Expression//Name/@Image, '.hasNext') or
    ends-with(Expression//Name/@Image, '.hasMoreElements')
  ) and not (
    starts-with(Expression//Name/@Image, concat(ForInit//VariableDeclaratorId/@Image, '.'))
  )
]
]]>
             </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class JumbledIteratorExample {
   public void someMethod() {
      for (int i = 0; i < ab.size(); i++) { } // ok
      for (Enumeration en = getEnum(); en2.hasMoreElements(); ) { } // maybe wrong
      for (Enumeration en2 = getEnum(); en.hasMoreElements(); ) { } // maybe wrong
      List al = new ArrayList();
      for (Iterator it2 = al.iterator(); it.hasNext(); ) { } // maybe wrong
      for (Iterator it = al.iterator(); it2.hasNext(); ) { } // maybe wrong
      for (int i = 0; i < MAX && clauses.hasNext(); i++) { } // ok
   }
}
]]>
      </example>
   </rule>


   <!-- naming.xml/controversial.xml -->
   <rule name="ParameterNameWithP"
         language="java"
         message="Method parameter names must start with 'p'."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#parameternamewithp">
      <description>
         All parameters of methods and constructors are required to be named like pXyz. Use Ctrl-1 to local rename it.
      </description>
      <priority>2</priority>
      <properties>
         <property name="prefix" type="String" description="Mandatory prefix to parameter names" value="p" />
         <property name="xpath">
            <value>
<![CDATA[
//FormalParameters/FormalParameter/VariableDeclaratorId[
  (not (starts-with(@Image, $prefix))) or
  (not (substring(@Image, 2, 1)=upper-case(substring(@Image, 2, 1))) )
]
]]>
            </value>
         </property>
      </properties>
      <example>
 <![CDATA[
class ParameterNameWithPExample {
   public SomeClass(String newNo) { } // wrong
   public SomeClass(int pYes) { }
   public void setNo(String newNo) { // wrong
      no = newNo;
   }
   public void setYes(String pYes) {
      yes = pYes;
   }
}
]]>
      </example>
   </rule>


   <!-- basic.xml -->
   <rule name="UnintendedEnvUsage"
         language="java"
         message="getBoolean, getInteger, getLong read from System Properties and do not parse."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#unintendedenvusage">
      <description>
         The methods getBoolean, getInteger and getLong read from environment (System Properties) and do not parse.
         Use Integer.parseInt() instead.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[
  @Image='Integer.getInteger' or
  @Image='Boolean.getBoolean' or
  @Image='Long.getLong'
]
]]>
            </value>
         </property>
      </properties>
      <example>
 <![CDATA[
class UnintendedEnvUsageExample {
   public void someMethod() {
      Boolean a = Boolean.getBoolean("true"); // does not work
      Boolean b = new Boolean("true"); // ok
      Long.getLong("3"); // does not work
      Long.parseLong("3"); // ok
   }
}
]]>
      </example>
   </rule>


   <!-- junit.xml -->
   <rule name="JunitSetupDoesNotCallSuper"
         language="java"
         message="Methods setUp and tearDown in JUnit tests must call super.setUp/tearDown."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#junitsetupdoesnotcallsuper">
      <description>
         The framework methods setUp() and tearDown() of JUnit's Testcase must always call super.setUp() and
         super.tearDown() to enable proper preparing and cleaning of resources.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//MethodDeclarator[
  ( @Image='setUp' and count(FormalParameters/*)=0 and
    count(../Block//PrimarySuffix[@Image='setUp'])=0
  ) or
  ( @Image='tearDown' and count(FormalParameters/*)=0 and
    count(../Block//PrimarySuffix[@Image='tearDown'])=0
  )  or
  ( @Image='onSetUp' and count(FormalParameters/*)=0 and
    count(../Block//PrimarySuffix[@Image='onSetUp'])=0
  )  or
  ( @Image='onTearDown' and count(FormalParameters/*)=0 and
    count(../Block//PrimarySuffix[@Image='onTearDown'])=0
  )
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
class BadTestCase extends TestCase {
   protected void setUp() throws Exception {
      // super.setUp(); - is missing
      prepareSomething();
   }
   protected void tearDown() throws Exception {
      releaseSomething();
      // super.tearDown(); - is missing
   }
}
]]>
      </example>
   </rule>


   <!-- naming.xml/controversial.xml --> <!-- by Richard Beitelmair -->
   <rule name="InterfaceNamesEndWithIF"
         language="java"
         message="Interface names should end with 'IF'."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#interfacenamesendwithif">
      <description>
         For better recognition interface names should end with 'IF'. Rename the interface!
      </description>
      <priority>2</priority>
      <properties>
         <property name="suffix" type="String" description="Mandatory suffix to interface names" value="IF" />
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='true' and
                              not (ends-with(@Image, $suffix))]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public interface SomeInterface { }     // nok
public interface SomeInterfaceF { }    // nok
public interface SomeInterfaceIF { }   // ok
public class SomeClass { }             // ok
]]>
      </example>
   </rule>


   <!-- naming.xml/controversial.xml -->
   <rule name="InterfaceNamesStartWithI"
         language="java"
         message="Interface names should start with 'I'."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#interfacenamesstartwithi">
      <description>
         For better recognition interface names should start with 'I'. Rename the interface!
      </description>
      <priority>2</priority>
      <properties>
         <property name="prefix" type="String" description="Mandatory prefix to interface names" value="I" />
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='true' and not (starts-with(@Image, $prefix))]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public interface SomeInterface { }     // nok
public interface SomeInterface { }     // nok
public interface ISomeInterface { }    // ok
public class SomeClass { }             // ok
]]>
      </example>
   </rule>


   <!-- migrating.xml --> <!-- by Richard Beitelmair -->
   <rule name="AtomWrapperInstantiation"
         language="java"
         since="3.5"
         message="Avoid instantiating Wrapper Type objects. Call Type.valueOf() instead."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#atomwrapperinstantiation">
      <description>
         In JDK 1.5, calling new Type() causes memory allocation. Type.valueOf() is more memory friendly.
      </description>
      <!-- Rule copied from PMD's migrating.xml/IntegerInstantiation, but for all types at once -->
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//PrimaryPrefix/AllocationExpression[
  not (ArrayDimsAndInits) and
  (
    ClassOrInterfaceType/@Image='Byte' or ClassOrInterfaceType/@Image='java.lang.Byte' or
    ClassOrInterfaceType/@Image='Short' or ClassOrInterfaceType/@Image='java.lang.Short' or
    ClassOrInterfaceType/@Image='Integer' or ClassOrInterfaceType/@Image='java.lang.Integer' or
    ClassOrInterfaceType/@Image='Long' or ClassOrInterfaceType/@Image='java.lang.Long' or
    ClassOrInterfaceType/@Image='Character' or ClassOrInterfaceType/@Image='java.lang.Character'
  )
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class AtomWrapperInstantiationExample {
    Byte myByte = new Byte(1);    // bad
    Byte byte2 = Byte.valueOf(1); // ok
    Short myshort = new Short(20);       // bad
    Short myshort2 = Short.valueOf(20);  // ok
    Integer integer = new Integer(4);      // bad
    Integer integer2 = Integer.valueOf(4); // ok
    Long myLong = new Long(10000000);       // bad
    Long myLong2 = Long.valueOf(10000000);  // ok
    Character myChar = new Character('x');    // bad
    Character char2 = Character.valueOf('x'); // ok
}
]]>
      </example>
   </rule>


   <!-- migrating.xml -->
   <rule name="CharInstantiation"
         language="java"
         since="4.0"
         message="Avoid instantiating Character objects. Call Character.valueOf() instead."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#charinstantiation">
      <description>
         In JDK 1.5, calling new Character() causes memory allocation. Character.valueOf() is more memory friendly.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//PrimaryPrefix/AllocationExpression[
  not (ArrayDimsAndInits) and
  ( ClassOrInterfaceType/@Image='Character' or ClassOrInterfaceType/@Image='java.lang.Character' )
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class CharInstantiationExample {
    Character char1 = new Character('x');     // bad
    Character char2 = Character.valueOf('x'); // ok
}
]]>
      </example>
   </rule>


   <!-- strictexception.xml --> <!-- by Manuel Tichy -->
   <rule name="NonFinalFieldInException"
         language="java"
         message="Exceptions must be immutable."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#nonfinalfieldinexception">
      <description>
         Exceptions must be immutable, so the fields of an Exception must be declared as final.
      </description>
      <priority>2</priority>
      <properties>
         <property name="suffix" type="String" description="Suffix of Exception names (to identify)" value="Exception" />
         <property name="xpath">
            <value>
<![CDATA[
//FieldDeclaration[ @Final='false' and
                    ../../../../ClassOrInterfaceDeclaration[ends-with(@Image, $suffix)] ]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class BadException extends Exception {
    private static long serialVersionUID = 1900926677490660714L; // Not ok - must be final!
    private String state;                                        // Not ok - must be final!
    public BadException(String message) {
        super(message);
    }
}
]]>
      </example>
   </rule>


   <!-- design.xml --> <!-- by Manuel Tichy -->
   <rule name="AvoidPrivateGetterAndSetter"
         language="java"
         message="Don't use private getters/setters."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#avoidprivategetterandsetter">
      <description>
         Instead of using private getter or setter, we use the member variable instead. It's easier to read and saves lines of code.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//MethodDeclaration [
  @Private='true' and
  @Synchronized='false' and
  count(Block/BlockStatement)=1 and
  (
     (
        MethodDeclarator[starts-with(@Image,'set')] and
        MethodDeclarator/FormalParameters[count(FormalParameter)=1] and
        ResultType[count(Type)=0] and
        Block/BlockStatement/Statement/StatementExpression/Expression/PrimaryExpression[
           (count(PrimarySuffix/Arguments)=0) and
           (count(descendant::Expression)=0)
        ] and //AssignmentOperator[@Image='=']
     ) or (
        MethodDeclarator[starts-with(@Image,'get') or starts-with(@Image,'is')] and
        MethodDeclarator/FormalParameters[count(FormalParameter)=0] and
        ResultType/Type[count(ReferenceType)=1] and
        Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression[
           (count(PrimarySuffix/descendant::*)=0) and
           (count(descendant::Expression)=0) and
           (count(descendant::AllocationExpression)=0)
        ] and
        count(Block/BlockStatement/Statement/ReturnStatement)=1
     )
  )
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
class AvoidPrivateGetterAndSetterExample {
   String myVariable;
   private void setMyVariable(String pMyVariable) {    // useless
      myVarialbe = pMyVariable;
   }
   ...
   myVariable = "asdfasdf";      // good, use the member variable instead of
}
]]>
      </example>
   </rule>


   <!-- design.xml --> <!-- by Manuel Tichy -->
   <rule name="MembersMustBePrivate"
         language="java"
         message="Members must be private except they are static and final"
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#membersmustbeprivate">
      <description>
         Members must be private, except static final constants. Change Member to private and create getter and/or setter to access value/s.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//FieldDeclaration[@Private='false' and (@Static='false' or @Final='false')]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class MembersMustBePrivateExample {
   public int z1 = 1;      // WRONG must be private
   private int z2 = 2;     // OK its private (without static and final)
   protected int z3;       // WRONG must be private

   public static int z4 = 1;     // WRONG final is missing
   private static int z5 = 2;    // OK its private (with static)
   protected static int z6 = 3;  // WRONG final is missing

   public static final int z7 = 1;     // OK because static + final
   private static final int z8 = 2;    // OK its private (with static + final)
   protected static final int z9 = 3;  // OK because static + final
]]>
      </example>
   </rule>


   <!-- strictexeption.xml -->
   <rule name="SignatureDeclareThrowsException"
         language="java"
         since="3.1"
         message="A method/constructor shouldn't explicitly throw java.lang.Exception."
         class="org.codecop.pmd.rule.ExceptionSignatureDeclaration"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#signaturedeclarethrowsexception">
      <description>
         It is unclear which exceptions that can be thrown from the methods. It might be difficult to document and
         understand the vague interfaces. Use either a class derived from RuntimeException or a checked exception.
      </description>
      <!-- Rule copied from PMD 3.1 (no type inference), but only allow exceptions for methods "setUp", "tearDown" -->
      <priority>2</priority>
      <properties>
          <property name="ignoreTests" type="Boolean" description="Ignore test methods" value="false" />
      </properties>
      <example>
<![CDATA[
public void methodThrowingException() throws Exception { }
]]>
      </example>
   </rule>


   <!-- naming.xml -->
   <rule name="ClassNamingConventions"
         language="java"
         since="3.1"
         message="Class names should begin with an uppercase character, not include underscores or dollar signs."
         class="org.codecop.pmd.rule.ClassNamingConventions"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#classnamingconventions">
      <description>
         Class names should always begin with an upper case character, and should not contain underscores
         (but _Stub or _Core) or dollar signs. Class names should not be upper case only.
      </description>
      <!-- Rule copied from PMD 3.1 and made it a bit more strict -->
      <priority>2</priority>
      <properties>
         <property name="upperCaseLen" type="Integer" description="Allowed length of upper case only names" min="1" max="99" value="3" />
      </properties>
      <example>
<![CDATA[
public class FOOBAR {}   // bad
public class Foo_Bar {}  // bad
public class Foo$Bar {}  // bad

public class URI {}      // ok - short abbrev
public class Foo_Stub {} // ok - created by RMI compiler
public class Foo_Core {} // ok - Generation Gap Pattern
]]>
      </example>
   </rule>


   <!-- logging-java.xml -->
   <rule name="LoggerHasWrongCategory"
         language="java"
         message="Logger has wrong category."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#loggerhaswrongcategory">
      <description>
         Logger is created for another category than the enclosing class. This is a typical copy-paste error.
      </description>
      <priority>2</priority>
      <properties>
         <property name="logFactory" type="String" description="Invocation of logger factory" value="Logger.getLogger" />
         <!-- for Commons Logging: LogFactory.getLog -->
         <property name="xpath">
            <value>
<![CDATA[
//PrimaryExpression
[
  (PrimaryPrefix/Name/@Image=$logFactory) and
  (not (PrimarySuffix//ClassOrInterfaceType/@Image=ancestor::ClassOrInterfaceDeclaration/@Image))
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
class GoodExample {
   private final Logger log = Logger.getLogger(GoodExample.class);
}
class BadExample {
   private final Logger log = Logger.getLogger(GoodExample.class);
}
]]>
      </example>
   </rule>


   <!-- strictexception.xml/controversial.xml/typeresolution.xml -->
   <rule name="AvoidThrowingCheckedException"
         language="java"
         message="Avoid throwing checked exceptions."
         class="org.codecop.pmd.rule.AvoidThrowingCheckedException"
         typeResolution="true"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#avoidthrowingcheckedexception">
      <description>
         Avoid throwing checked Exceptions - it's considered noise.
      </description>
      <priority>2</priority>
      <example>
<![CDATA[
public class Foo {
  void bar() throws IOException {
    throw new IOException();
  }
}
]]>
      </example>
   </rule>


   <!-- naming.xml -->
   <rule name="ShortVariableCustom"
         language="java"
         since="0.3"
         message="Avoid variables with short names like {0}."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#shortvariablecustom">
       <description>
          Detects when a field, local, or parameter has a very short name.
       </description>
       <priority>3</priority>
       <properties>
           <property name="minLen" type="Integer" description="Minimal length of variable names" min="1" max="99" value="3" />
           <property name="xpath">
               <value>
<![CDATA[
//VariableDeclaratorId[string-length(@Image) < $minLen]
  [not(ancestor::ForInit)]
  [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
]]>
               </value>
           </property>
       </properties>
       <example>
<![CDATA[
public class Something {
  private int q = 15; // VIOLATION - Field
  public static void main(String[] as) {  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local
    for (int i = 0; i < 10; i++) { // Not a Violation (inside FOR)
      r += q;
    }
  }
}
]]>
       </example>
   </rule>


   <!-- imports --> <!-- by Usman Ismail -->
   <rule name="DontImportWild"
         language="java"
         message="No wild card imports."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#dontimportwild">
      <description>
         Do not use wild card imports such as java.net.*.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
/ImportDeclaration[@PackageName=@ImportedName]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
import java.net.*; // is bad
import java.net.URL; // is better
]]>
      </example>
   </rule>


   <!-- design --> <!-- by Usman Ismail -->
   <rule name="PrivateInjections"
         language="java"
         message="Make injected fields private."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#privateinjections">
      <description>
         Set all injected fields to private.
      </description>
      <priority>1</priority>
      <properties>
         <property name="inject" type="String" description="Name of Inject annotation" value="Inject" />
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceBodyDeclaration[contains(Annotation//Name/@Image, $inject) and
                                  contains(FieldDeclaration/@Private, 'false')]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
@Inject
public String badParameter; // is bad

@Inject
private String goodParameter; // is better
]]>
      </example>
   </rule>


   <!-- junit.xml --> <!-- by Florian and Roland of LOT team -->
   <rule name="JUnitTestsShouldIncludeAssertOrVerify"
         message="JUnit tests should include at least one assertion (assert(), fail() or verify())."
         class="org.codecop.pmd.rule.JUnitTestsShouldIncludeAssertOrVerify"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#junittestsshouldincludeassertorverify">
      <description>
        JUnit tests should include at least one assertion. This makes the tests more robust, and
        using assert with messages provide the developer a clearer idea of what the test does.
      </description>
      <priority>3</priority>
      <example>
<![CDATA[
public class Foo extends TestCase {
  public void testSomething() {
    Bar b = findBar();
    // This is better than having a NullPointerException
    // assertNotNull("bar not found", b);
    b.work();
  }
}
]]>
      </example>
   </rule>


   <!-- design.xml -->
   <rule name="PrimitiveObsession"
         language="java"
         since="5.0"
         message="Introduce a ValueObject in place of the primitive data."
         class="org.codecop.pmd.rule.PrimitiveObsession"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#primitiveobsession">
      <description>
         You are likely using primitive data types to represent domain ideas. For example, a String to
         represent a message, an Integer to represent an amount of money, or a Struct/Dictionary/Hash to
         represent a specific object. You should introduce a ValueObject in place of the primitive data.
      </description>
      <priority>2</priority>
      <properties>
          <property name="allowObject" type="Boolean" description="Allow plain java.lang.Object" value="true" />
          <property name="checkConstructors" type="Boolean" description="Check public constructors for more than one primitive" value="false" />
      </properties>
      <example>
<![CDATA[
class BadObject {
   public void badVoidMethod(String a, String b) { };
   public String badMixedMethod(Date when) { };
}
]]>
      </example>
   </rule>


   <!-- strictexception.xml --> <!-- by Richard Beitelmair -->
   <rule name="MutableException"
         language="java"
         message="Avoid non final attributes in exceptions."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#mutableexception">
      <description>
         Exception instances should represent an error condition. Having non final fields allows
         the state to be modified by accident and therefore mask the original condition.
      </description>
      <priority>2</priority>
      <properties>
         <property name="suffix" type="String" description="Suffix of Exception names (to identify)" value="Exception" />
         <property name="xpath">
            <value>
<![CDATA[
//FieldDeclaration[@Final='false' and
                   ../../..[ends-with(@Image, $suffix) or ends-with(@Image, 'Error')]]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class ChannelException {
   private final String channel; // ok
   private boolean showIfSearchedInRegion; // not ok
}
public class ChannelPolicyError {
   private final String channel;  // ok
   private final boolean showIfSearchedInRegion; // ok
}
]]>
      </example>
   </rule>
   <!-- might use Type resolution to find super class instead of relying on class name -->


   <!-- design.xml --> <!-- by Richard Beitelmair -->
   <rule name="ImmutablesOnly"
         language="java"
         message="Avoid mutable state, make all fields final."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#immutablesonly">
      <description>
         Immutable data structures are easier to reason about and have no concurrency issues.
         Only final fields are allowed. (Mutable field references should be copied when passed in or out, but that is not checked.)
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//FieldDeclaration[@Final='false']
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class SomeClass {
   private final String channel; // ok
   private boolean showIfSearchedInRegion; // not ok
}
]]>
      </example>
   </rule>


   <!-- design.xml -->
   <rule name="OneLevelOfIntention"
         language="java"
         message="Maximum nesting of one per method."
         class="org.codecop.pmd.rule.LevelOfIntentation"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#onelevelofintention">
      <description>
         Use only a maximum of one level of intention per method. You cannot nest if, loops or trys-
         This enforces SRP split on method level. This is rule 1 of Object Calisthenics.
      </description>
      <priority>2</priority>
      <properties>
         <property name="problemDepth" type="Integer" description="Maximum allowed nesting depth." min="1" max="25" value="1" />
      </properties>
      <example>
<![CDATA[
public class Foo {
    public void okBecauseOneBlock() {
        if (true) {
            // ok, only one block
        }
    }
    public void failBecauseNested() {
        if (true) {
            while(true) {  } // nesting 2
        }
    }
}
]]>
      </example>
   </rule>


   <!-- design.xml -->
   <rule name="ZeroLevelOfIntention"
         language="java"
         message="Only one Level of intention per method."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#zerolevelofintention">
      <description>
         Use only one level of intention per method. You cannot use if, loops or try more than
         once in a method. If used they need to be the first/last/outer statement of the method.
         This enforces SRP split on method level. This is rule 1 of (strict) Object Calisthenics.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <!-- xpath: find methods which
                             have more than one If/Switch/.../Do Statement inside
                             or have blocks with If/Switch/.../Do Statement which are in a group of more than one other block
            -->
            <value>
<![CDATA[
//MethodDeclaration[
        count( descendant::IfStatement | descendant::SwitchStatement | descendant::TryStatement |
               descendant::ForStatement | descendant::WhileStatement | descendant::DoStatement ) > 1
        or Block/BlockStatement[
            count( Statement[IfStatement | SwitchStatement | TryStatement | ForStatement | WhileStatement | DoStatement] ) > 0 and
            count( parent::Block/BlockStatement ) > 1
                ]
    ]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
    public void okBecauseOneBlock() {
        if (true) {
            // ok, only one block
        }
    }
    public void failBecauseNested() {
        if (true) {
            while(true) {  }
        }
    }
}
]]>
      </example>
   </rule>


   <!-- design.xml -->
   <rule name="FirstClassCollections"
         language="java"
         message="Any class that contains a collection (or array) should contain no other member variables."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#firstclasscollections">
      <description>
         Each collection gets wrapped in its own class, so now behaviour related to the collection have a home.
         Constants do not count.
         This is rule 4 of Object Calisthenics.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <!-- xpath: find collection fields with more than 1 siblings -->
            <value>
<![CDATA[
//FieldDeclaration[
        ( @Array='true' or
          Type[@TypeImage='List' or @TypeImage='Set' or @TypeImage='SortedSet' or @TypeImage='NavigableSet' or
               @TypeImage='Map' or @TypeImage='SortedMap' or @TypeImage='NavigableMap' or
               @TypeImage='Collection' or @TypeImage='Deque' or @TypeImage='Queue' ]
        ) and
        count( //FieldDeclaration[@Static='false' or @Final='false'] ) > 1
    ]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class FooMap {
    private Map map; // ok
}
public class Mixup {
    private Map map;
    private int i; // yuk
}
]]>
      </example>
   </rule>


   <!-- naming.xml -->
   <rule name="AvoidClassNamingImpl"
         language="java"
         message="Implementation classes should not end with 'Impl'."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#avoidclassnamingimpl">
      <description>
         For better naming implementation classes should not end with 'Impl'. Rename the class!
      </description>
      <priority>2</priority>
      <properties>
         <property name="suffix" type="String" description="Forbidden suffix to class names" value="Impl" />
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[ends-with(@Image, $suffix)]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class SomeImpl { }     // nok
public class SomeClass { }    // ok
]]>
      </example>
   </rule>


   <!-- junit.xml --> <!-- by Marek Budyn -->
   <rule name="TestNameShouldStartWithShould"
         language="java"
         message="Test method must start with 'should'."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#testnameshouldstartwithshould">
      <description>
         Write your tests in the behaviour driven development style of testing, as it encourages you to write tests that
         read as specifications, and are more aligned with the behaviour of the class or system that you are testing.
      </description>
      <priority>2</priority>
      <properties>
         <property name="classSuffix" type="String" description="Suffix to test class names (to identify)" value="Test" />
         <property name="methodPrefix" type="String" description="Mandatory prefix to test methods" value="should" />
         <property name="xpath">
            <value>
<!-- PMD 5.1: //MethodDeclaration[(../Annotation/MarkerAnnotation/Name[@Image='Test']) and (not(starts-with(@Name, 'should')))] -->
<![CDATA[
//MethodDeclaration[
    (../Annotation/MarkerAnnotation/Name[@Image=$classSuffix])
    and
    (not(starts-with(MethodDeclarator/@Image, $methodPrefix)))
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class GoodNamedTest {
  @Test
  public void shouldRun() { // ok
  }
}

public class BadNamedTest {
  @Test
  public void testRun() { // nok
  }
}
]]>
      </example>
   </rule>


   <!-- design.xml --> <!-- by Dieter Herndlhofer -->
   <rule name="NoCasts"
         language="java"
         message="Do not cast objects, use polymorphy."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#nocasts">
      <description>
         Type casting an object to a subclass' type is not object oriented. Use polymorphy to access the behaviour you need.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//CastExpression/Type/ReferenceType[
  not (ancestor::MethodDeclaration/@MethodName='equals')
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class OneCast {
  private void run(Object param) {
    Integer var = (Integer) param; // Don't do that
  }
  private void run(long param) {
    int var = (int) param; // truncating is ok
  }
}
]]>
      </example>
   </rule>


   <!-- codesize.xml -->
   <rule name="TooManyPublicMethods"
         language="java"
         message="This class has too many public methods, consider refactoring it."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#toomanypublicmethods">
      <description>
        A class with too many public methods is probably a good suspect for refactoring,
        to reduce its complexity and find a way to have more fine grained objects.
      </description>
      <priority>2</priority>
      <properties>
         <property name="maxMethods" type="Integer" description="The method count reporting threshold" min="1" max="1000" value="3"/>
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody[
    count(descendant::MethodDeclaration[@Public = 'true']) > $maxMethods
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
  public void one() {}
  public void two() {}
  public void three() {}
  public void four() {} // too many
}
]]>
      </example>
   </rule>


   <!-- codesize.xml -->
   <rule name="TooManyInterfaceMethods"
         language="java"
         message="This interface has too many public methods, consider splitting it."
         class="net.sourceforge.pmd.lang.rule.XPathRule"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#toomanyinterfacemethods">
      <description>
        An interface with too many methods is an ISP (SOLID) violation and needs to be refactored,
        to reduce its complexity and find a way to have more fine grained objects.
      </description>
      <priority>2</priority>
      <properties>
         <property name="maxMethods" type="Integer" description="The method count reporting threshold" min="1" max="1000" value="3"/>
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[
    (@Interface='true') and
    (ClassOrInterfaceBody[ count(descendant::MethodDeclaration) > $maxMethods ])
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public interface Foo {
  void one();
  void two();
  void three();
  void four(); // too many
}
]]>
      </example>
   </rule>


   <!-- codesize.xml -->
   <rule name="ExcessiveClassCount"
         language="java"
         message="Package {0} has too many classes."
         class="org.codecop.pmd.rule.ExcessiveClassCount"
         externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#excessiveclasscount">
      <description>
         Limit the number of classes per package. Keep packages small and focused.
      </description>
      <priority>2</priority>
      <properties>
         <property name="maxClasses" type="Integer" description="Maximum allowed classes in package." min="1" max="999" value="20" />
      </properties>
   </rule>


   <!-- design.xml -->
   <rule name="LawOfDemeter"
          language="java"
          since="5.0"
          message="Potential violation of Law of Demeter"
          class="org.codecop.pmd.rule.LawOfDemeterRule"
          externalInfoUrl="https://github.com/codecop/pmd-rules/wiki/PmdRulesCodecop#lawofdemeter">
        <description>
          The Law of Demeter is a simple rule, that says "only talk to friends". It helps to reduce coupling between classes
          or objects.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
public class Foo {
    /**
     * This example will result in two violations.
     */
    public void example(Bar b) {
        // this method call is ok, as b is a parameter of "example"
        C c = b.getC();

        // this method call is a violation, as we are using c, which we got from B.
        // We should ask b directly instead, e.g. "b.doItOnC();"
        c.doIt();

        // this is also a violation, just expressed differently as a method chain without temporary variables.
        b.getC().doIt();

        // a constructor call, not a method call.
        D d = new D();
        // this method call is ok, because we have create the new instance of D locally.
        d.doSomethingElse(); 
    }
}
]]>
        </example>
    </rule>
</ruleset>
