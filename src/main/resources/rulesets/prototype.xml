<?xml version="1.0"?>
<ruleset name="Prototype Rules"
    xmlns="http://pmd.sf.net/ruleset/1.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd"
    xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd">

   <description>
      These rules are very specific and not useable on general code. But they serve as examples and prototypes to copy from.
   </description>


   <!-- typeresolution.xml -->
   <rule name="EntityWithReferences"
         since="3.9"
         message="Entities must define all attributes with RelationShips"
         class="org.codecop.pmd.prototype.EntityWithReferences"
         typeResolution="true">
      <description>
         In a specific Rich Domain Model all Entities (subclasses of Entity) must define their attributes as (subclasses of) RelationShips.
         Simple attributes are not allowed. To fix this rule, wrap all simple attributes with a RelationShip of proper type accordingly.
      </description>
      <priority>2</priority>
      <example>
<![CDATA[
public class RelationShip<T> { }
public class BetterRelationShip<T> extends RelationShip<T> { }
public class Entity { }
public class BetterEntity extends Entity { }
public class BadEntity extends BetterEntity {
   private RelationShip<MyString> astring; // ok
   private MyString bstring; // wrong
   private int bint; // wrong
}
]]>
      </example>
   </rule>


   <!-- typeresolution.xml -->
   <rule name="ImmutableValueObject"
         since="3.9"
         message="ValueObjects must not define RelationShips and be immutable"
         class="org.codecop.pmd.prototype.ImmutableValueObject"
         typeResolution="true">
      <description>
         In a specific Rich Domain Model all Value Objects (subclasses of ValueObjects) must not define their attributes as (subclasses of) 
         RelationShips. Just simple attributes are allowed. 
      </description>
      <priority>2</priority>
      <example>
<![CDATA[
public class ValueObject { }
public class BadValueObject extends ValueObject {
   private MyString astring;
   private BetterRelationShip<MyString> bstring; // wrong
   public void changeAstring(MyString string) { // wrong
      astring = string;
   }
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="EmptyFunction"
         message="The given method must be implemented and not just return null."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         Some abstract methods, e.g. getActionShortName() in subclasses of HBDAction, must not return null. If they will never be called, throw a OperationNotSupportedException.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//ClassDeclaration//MethodDeclaration
  [MethodDeclarator [@Image='getActionShortName' or @Image='toDom' or @Image='toString' ] ]
  [Block//ReturnStatement//NullLiteral]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class FooAction {
 public String getActionShortName() {
   // should return some string for the statistic
   return null;
 }
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDLibraryRuleForSOAP"
         message="SOAP must only be used inside at.herold.sup.soap."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         The SOAP library must only be used inside the package at.herold.sup.soap. Other packages must not import it.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//ImportDeclaration/Name[
  starts-with(@Image,'org.apache.axis') and
  //PackageDeclaration/Name[(not (starts-with(@Image,'at.herold.sup.soap')))]
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
package at.herold.a; // other than at.herold.sup.soap
import org.apache.axis.abc.Call;

public class Foo { }
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDCommitInDBLayer"
         message="Classes in DB layer must not call Connection.commit."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         HBDActions are responsible for maintaining transactions, so classes in the DB layer are not allowed to call
         Connection.commit. commit is reserved word and should also not be used as identifier.
      </description>
      <priority>2</priority>
      <!-- author>Martina Stoiber</author -->
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//PrimaryExpression[
   ( PrimaryPrefix/Name[ends-with(@Image, '.commit')] or PrimarySuffix[@Image='commit'] ) and
   //PackageDeclaration[Name[ends-with(@Image, '.resultlist') ]]
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
package at.herold.sp.resultlist;

public class BadGuy {

   public void method() {
      System.out.println("bubu");

      Connection con = getConnection();
      con.commit(); // 9
      System.out.println("we did it");

      getConnection().commit(); // 12
      System.out.println("we did it again");

      // would be ok, but may warn as well
      int commit;
      commit = 3;
      long commit = 3L;
      other.commit(bla); // 19
      other.commitIt(bla);
      other.commit2();
      other.Somecommit();
   }
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDCall4TestNotInJunit"
         message="Only Classes in junit packages may call *4Test() methods."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         Only test classes in .junit packages are allowed to call special test methods on objects, which are called *4Test.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//PrimaryExpression[
   ( PrimaryPrefix/Name[ends-with(@Image, '4Test')] or PrimarySuffix[ends-with(@Image, '4Test')] ) and
   //PackageDeclaration[Name[(not(ends-with(@Image, '.junit'))) ]]
]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
package at.herold.sp.db.notjunit;

public class BadGuy {

   public void method() {
      System.out.println("bubu");

      Object con = getObject();
      con.run4Test(); // 9
      int result = con.run4Test(params); // 10
      System.out.println("we did it");

      getObject().run4Test(); // 13
      int res = getObject().run4Test(params); // 14
      System.out.println("we did it again");
   }

   public void method4Test() {
      // is allowed
   }
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDMoreThanOneLogger"
         message="Class contains more than one Logger"
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         Normally only one HBD logger is used in each class.
      </description>
      <!-- Rule copied from PMD, but changed name of Logger -->
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//ClassBody[ count(//VariableDeclarator[../Type/Name[@Image='LoggerImpl']]) >1 ]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
class Foo {
   LoggerImpl logger = LoggerUtil.getLogger(Foo.class);
   // It is very rare to see two loggers on a class, normally
   // log information is multiplexed by levels
   LoggerImpl log2 = LoggerUtil.getLogger(Foo.class.getName());
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDLoggerIsNotStaticFinal"
         message="The HBD Logger variable declaration does not contain the static and final modifiers"
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         In most cases, the Logger can be declared private static and final.
      </description>
      <!-- Rule copied from PMD, but changed name of Logger -->
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//VariableDeclarator[../Type/Name[@Image='LoggerImpl'] and (..[@Final='false'] or ..[@Static = 'false'] or .. [@Private = 'false']) ]
]]>
            </value>
         </property>
      </properties>
      <example>
 <![CDATA[
class Foo {
    LoggerImpl logger = LoggerUtil.getLogger(Foo.class);
    // It is much better to declare the logger as follows
    // static final LoggerImpl logger = LoggerUtil.getLogger(Foo.class);
}
]]>
      </example>
   </rule>


   <!-- TODO --> <!-- by Richard Beitelmair -->
   <rule name="HBDNoAttrInPolicyAndPlugOn"
         message="Avoid non final attributes in policies and plugons."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         Policies (Navigation) and Plugons (Adworx) are not threadsafe, therefore we do not allow non final members.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//FieldDeclaration[@Final='false' and ../../..[ends-with(@Image,'PlugOn') or ends-with(@Image,'Policy')]]
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
public class SPAdWorxChannelPlugOn {
   private final String channel; // ok
   private boolean showIfSearchedInRegion; // not ok
}
public class SPAdWorxChannelPlugOnKey {
   private final String channel;  // ok
   private boolean showIfSearchedInRegion; // ok
}
public class SPPolicy {
   private final String channel; // ok
   private boolean showIfSearchedInRegion; // not ok
}
public class SPPolitesse {
   private final String channel;  // ok
   private boolean showIfSearchedInRegion; // ok
}
]]>
      </example>
   </rule>


   <!-- TODO --> <!-- by Manuel Tichy -->
   <rule name="HBDExceptionNotAllowed"
         message="The use of HBDException is not allowed anymore."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         The framework is only using RunntimeExceptions. Checked Exceptions are not allowed anymore.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceType[@Image='HBDException']
]]>
            </value>
         </property>
      </properties>
      <example>
<![CDATA[
class MyClass extends OtherClass
{
   public void myMethod()  throws HBDException  // "throws HBDException" is not allowed!
   {
      try
      {
         ...
         throw new HBDException("...");   // "throw new HBDException" is not allowed!
      }
      catch(final HBDException e)   // "catch HBDException" is not allowed!
      {
         ...
      }
   }
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDActionHasNoShortName"
         message="All concrete (not abstract) actions must implement the getActionShortName method."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         In most cases, the Logger can be declared static and final.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//ClassDeclaration[@Abstract='false' and
  //UnmodifiedClassDeclaration[ends-with(@Image,'Action') and (not(ends-with(@Image,'HelperAction')))] and
  count(//MethodDeclarator[@Image='getActionShortName']) =0 ]
]]>
            </value>
         </property>
      </properties>
      <example>
 <![CDATA[
public class FooAction {
   // typo occured
   public String getXActionShortName() {...}
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDJUnitTestHasWrongName"
         message="All concrete JUnit tests must be named ending with *Test or *TestManuell."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         All concrete JUnit tests must be named to the sheme of ending with *Test or *TestManuell to be identified and run automatically.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//ClassOrInterfaceDeclaration[
   (not(ends-with(@Image, 'Test'))) and (not(ends-with(@Image, 'TestManuell')) and (not(@Image='TCInit')) and (not(@Image='TCShutdown'))) and
   (@Abstract='false') and
   (count(ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/MethodDeclarator[ starts-with(@Image, 'test') ])>0) and
   //PackageDeclaration[Name[(ends-with(@Image, '.junit')) or (ends-with(@Image, '.httpunit'))] ]
]   
]]>
            </value>
         </property>
      </properties>
      <example>
 <![CDATA[
package at.herold.sp.db.junit;

class BadTestClass {
   // this does not end with Test
   public void testMethod() {
   }
}

abstract class GoodAbstract {
   // is abstract, name as it likes
   public void testMethod() {
   }
}

class GoodTest {
   public void testMethod() {
   }
}

class OtherClass {
   // other class in package, ok
   public void noTestMethod() {
   }
}
]]>
      </example>
   </rule>


   <!-- TODO -->
   <rule name="HBDNewEnumOnlyInside"
         message="Enums must only be instantiated inside its Enum class itself."
         class="net.sourceforge.pmd.rules.XPathRule">
      <description>
         Enums are special instances and not meant to be created by other classes, instead use a getEnumFor(value) on the Enum itself.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value>
<![CDATA[
//AllocationExpression[
   (ends-with(ClassOrInterfaceType/@Image, 'Enum')) and (count(ArrayDimsAndInits)=0) and
   (not(//ClassOrInterfaceDeclaration/@Image=ClassOrInterfaceType/@Image)) ]
]]>
            </value>
         </property>
      </properties>
      <example>
 <![CDATA[
class MyEnum {
   public void foo() {
      new MyEnum(); // is ok
   }
}
class OtherEnum {
   public void foo() {
      new MyEnum(); // is forbidden
   }
}
class OtherClass {
   public void foo() {
      new MyEnum[0]; // array is ok
   }
}
]]>
      </example>
   </rule>
   
</ruleset>
